<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Daniel Suttor</title><link>http://dasutt.github.io/</link><description>This is the personal website of Daniel Suttor.</description><atom:link href="http://dasutt.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Wed, 19 Jul 2017 09:00:19 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Volumetric Particles Part 1 - Adaptive Grid</title><link>http://dasutt.github.io/posts/volumetric-particles-part-1-adaptive-grid/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;div&gt;&lt;p&gt;This is the first part of a series of blog posts covering the details of my master's
thesis. An overview of this project can be found &lt;a class="reference external" href="http://dasutt.github.io/stories/volumetric-rendering"&gt;here.&lt;/a&gt;
The source code is available on &lt;a class="reference external" href="https://github.com/DaSutt/VolumetricParticles"&gt;github.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this post I am going to cover the data structure that is created on the CPU
and used during raymarching on the GPU to calculate the volumetric effects. I am
using a simple example scene for this. The subdivision of the grid can be seen in the
following screenshot:&lt;/p&gt;
&lt;img alt="/images/volumetric-particles/GridSubdivision.png" src="http://dasutt.github.io/images/volumetric-particles/GridSubdivision.png"&gt;
&lt;p&gt;It consists of the root node in the background, two nodes on the medium level and
four nodes on the highest resolution. The subdivision factor on each level is 16.
This creates a similar tree to &lt;a class="reference external" href="https://developer.nvidia.com/gvdb"&gt;GVDB.&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="node-data"&gt;
&lt;h2&gt;Node Data&lt;/h2&gt;
&lt;p&gt;The following buffers contain the data needed on the GPU for the adaptive grid:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NodeInfo - image and child offsets&lt;/li&gt;
&lt;li&gt;ActiveBits - bits to indicate which child nodes are active&lt;/li&gt;
&lt;li&gt;NodeCount - store the number of active nodes&lt;/li&gt;
&lt;li&gt;ChildIndices - index into the NodeInfo array for each child&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each node stores the 3D image offset into a 3D texture atlas which contains the
actual volumetric data. This image offset is packed into a 32bit unsigned integer
value. In addition to this an additional offset for mipmaps is stored. Each node
also stores the start offset into the child indices array.&lt;/p&gt;
&lt;p&gt;For the current subdivision factor of 16 it is necessary to store 16^3 bits for
all possible active children based on their positions inside of the parent node.
For each node 128 32bit unsigned integer values are
reserved inside the active bits array to store the child information. In addition
in the node count array the number bits are stored which have been set until this
position in the array.&lt;/p&gt;
&lt;p&gt;The find the index into the node info array for an active child bit counting is used.
To achieve this the node indices are stored inside the child indices array. Because
they are ordered based on the 1D index of the bits it is possible to find the
correct position in the child indices array from the active bits.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="example"&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;Using the same subdivision of the grid as in the example above the following data
on the different levels is stored:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="14%"&gt;
&lt;col width="14%"&gt;
&lt;col width="17%"&gt;
&lt;col width="11%"&gt;
&lt;col width="15%"&gt;
&lt;col width="13%"&gt;
&lt;col width="16%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Node Index&lt;/th&gt;
&lt;th class="head"&gt;Grid Level&lt;/th&gt;
&lt;th class="head"&gt;Node Position&lt;/th&gt;
&lt;th class="head"&gt;1D index&lt;/th&gt;
&lt;th class="head"&gt;Array Index&lt;/th&gt;
&lt;th class="head"&gt;Bit Index&lt;/th&gt;
&lt;th class="head"&gt;Child Offset&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0,0,0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;7,7,8&lt;/td&gt;
&lt;td&gt;2167&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8,7,8&lt;/td&gt;
&lt;td&gt;2168&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;15,15,6&lt;/td&gt;
&lt;td&gt;1791&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;15,15,7&lt;/td&gt;
&lt;td&gt;2047&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0,15,6&lt;/td&gt;
&lt;td&gt;1776&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0,15,7&lt;/td&gt;
&lt;td&gt;2032&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="45%"&gt;
&lt;col width="9%"&gt;
&lt;col width="9%"&gt;
&lt;col width="9%"&gt;
&lt;col width="9%"&gt;
&lt;col width="9%"&gt;
&lt;col width="9%"&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Child Indices&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The following calculations are performed:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1D index = (pos.z * resolution + pos.y) * resolution + pos.x&lt;/li&gt;
&lt;li&gt;Array Index = 1D index / 32&lt;/li&gt;
&lt;li&gt;Bit Index = 1D index % 32&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How this data is used on the GPU to traverse the grid is described in the next
blog post.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>http://dasutt.github.io/posts/volumetric-particles-part-1-adaptive-grid/</guid><pubDate>Wed, 19 Jul 2017 05:44:21 GMT</pubDate></item><item><title>More screenshots</title><link>http://dasutt.github.io/posts/more-screenshots/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;div&gt;&lt;p&gt;I added some screenshots of the volumetric rendering I am currently working on for my master thesis
&lt;a class="reference external" href="http://dasutt.github.io/stories/volumetric-rendering"&gt;here&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;I also added some reviews to a tool I wrote for AMD &lt;a class="reference external" href="http://dasutt.github.io/stories/open-capture-and-analytics-tool"&gt;OCAT&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;More information on both projects is to come after I finished writing my thesis.&lt;/p&gt;&lt;/div&gt;</description><guid>http://dasutt.github.io/posts/more-screenshots/</guid><pubDate>Sun, 21 May 2017 10:07:29 GMT</pubDate></item><item><title>Ifc to Unreal</title><link>http://dasutt.github.io/posts/ifc-to-unreal-post/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;p&gt;I wrote an article about a project to import architectural Ifc data into Unreal Engine.
We managed to import the complete mathematics - informatics building of our university.
More information about the import process and the different issues we faced can be found
&lt;a class="reference external" href="http://dasutt.github.io/stories/ifc-to-unreal"&gt;here&lt;/a&gt; .&lt;/p&gt;</description><category>Blender</category><category>C++</category><category>Unreal Engine</category><guid>http://dasutt.github.io/posts/ifc-to-unreal-post/</guid><pubDate>Sat, 15 Apr 2017 21:44:25 GMT</pubDate></item><item><title>Blender and DirectX projects</title><link>http://dasutt.github.io/posts/blender-and-directx-projects/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;div&gt;&lt;p&gt;I added two more projects I did some time ago:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Sandbox:&lt;/strong&gt; C++/DirectX application to test out different graphic effects&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ice base:&lt;/strong&gt; A 3D model I created from scratch&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>Blender</category><category>C++</category><category>DirectX 11</category><guid>http://dasutt.github.io/posts/blender-and-directx-projects/</guid><pubDate>Thu, 16 Jun 2016 14:46:15 GMT</pubDate></item><item><title>First project pages</title><link>http://dasutt.github.io/posts/first-project-pages/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;div&gt;&lt;p&gt;I added some of my projects to the project page:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Interactive Visual Data Analysis:&lt;/strong&gt; C++/DirectX tool for rendering of scientific volume data sets.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VR Exploration:&lt;/strong&gt; The results of my bachelor's thesis. A framework for Oculus Rift and Leap Motion for VR movement of data sets.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Into Darkness:&lt;/strong&gt; Detailed information on what I worked on during the Into Darkness project.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also added some information on other projects. However for those I have not
yet wrote a complete article. More will come later.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>DirectX 11</category><category>Leap Motion</category><category>Oculus Rift</category><guid>http://dasutt.github.io/posts/first-project-pages/</guid><pubDate>Fri, 27 May 2016 13:56:12 GMT</pubDate></item><item><title>Into Darkness Postmortem</title><link>http://dasutt.github.io/posts/into-darkness-postmortem/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;div&gt;&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Into Darkness is a top down isometric shooter game I developed with four other
students in a practical course during one semester at TUM. We decided to write
the whole game from scratch using C++ and DirectX. This proved to be quite a different
experience than other projects I did before. I will add more information on the
project page in the next time. In this post I want to give an overview of my experiences
during this project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-positive"&gt;
&lt;h2&gt;The Positive&lt;/h2&gt;
&lt;p&gt;I really liked the setting of our game. Our vision was to create a game where the
player would explore abandoned underground places and try to gather needed resources.
The idea was to increase the danger in form of aliens attacking the player while going
deeper underground. In the same way the player would find more resources in lower levels.
We wanted that light would play an important role both as an atmospheric element
and as a game mechanic to be used against the underground dwelling aliens. Overall
I think that could have created a quite interesting game experience.&lt;/p&gt;
&lt;p&gt;The best thing of the whole project was to develop the whole game from scratch.
While it was a lot of work it was also a great experience and a lot of fun to
see the game grow continually from nothing. For it was far more rewarding to get a
feature running properly than just using a pre made game engine like Unity.
Even though the progress is obviously a lot slower compared to using an engine you
can really understand what is running under the hood of the game.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-challenges"&gt;
&lt;h2&gt;The Challenges&lt;/h2&gt;
&lt;div class="section" id="concept-phase"&gt;
&lt;h3&gt;Concept Phase&lt;/h3&gt;
&lt;p&gt;While the initial concept definitely was interesting we made the mistake to not
concentrate on one specific feature but had a really broad set of features we wanted
to create. This especially proved a problem later in the development because we
had to divide our time between them instead of focusing on one at a time.
The general design was too ambitious to be achieved in the time we had.&lt;/p&gt;
&lt;p&gt;During the course we had to create a physical prototype before starting with the
development. While I can understand why one could use this to test an initial prototype
it is not usable during later development in my opinion. The game play can not
really transferred to the paper prototype. It would have been more useful to use an engine
to create small game play prototype during the development.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="programming"&gt;
&lt;h3&gt;Programming&lt;/h3&gt;
&lt;p&gt;Because of our design we started from the start to create systems specially for this,
making assumptions how we could improve the implementations early on. This was a
mistake which became apparent later in development when the requirements changed.
We had to change systems completely which would not have been such a problem if
we had started with a more flexible, general approach.&lt;/p&gt;
&lt;p&gt;Something we did not do during development was code review leading to quite interesting
commits from team members. Sometimes the game would not work almost at all
after changes made and we had to get back to previous commits.&lt;/p&gt;
&lt;p&gt;One problem during the development was definitely the lack of experience. Especially
the interaction between the different game components was quite hard. I would have
preferred to have someone with industry experience to provide some guidance during the
project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="art"&gt;
&lt;h3&gt;Art&lt;/h3&gt;
&lt;p&gt;A problem we had with most of our student game projects was the lack of artists.
If only programmers are on your team it will definitely show in the resulting assets.
For the project I did most of the modeling and texturing myself. Looking back at
the results which are more like placeholders than real art I think the realistic
art style was not the right decision. Some more abstract rendering would have helped
to make the game look more finished in my opinion.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="team-management"&gt;
&lt;h3&gt;Team management&lt;/h3&gt;
&lt;p&gt;Because most of the initial design was my idea and I also had done some of the basic
engine programming already I was really interested in getting stuff done for the game.
Due to this I tried to do as much as possible myself leading to a bad task
distribution overall.&lt;/p&gt;
&lt;p&gt;Task distribution in general proved to be quite some problem. There was a
difference in experience between the different team members which made it harder
to get important features done on time and with the correct quality. Communication
is really important to find out if a given task can be solved by the assigned
team member. We also had a new team member joining us almost at the end of the project.
Without much documentation it was quite hard for him to join the development.&lt;/p&gt;
&lt;p&gt;Another aspect of team management which did not always work was team motivation.
As with most other university projects some people see it more as an easy way
to get credits instead of working on the game. Fortunately, most of us were motivated
in the beginning. However, with the increasing complexity and more and more time constraints
in the end, this became a problem. To prevent this communication again is really
helpful. Not addressing problems like this right away can damage the relationship
between the team members really fast.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;By only looking of the final game I would say the project was not really successful.
This has different reasons: First the presentation of the final game is not polished
enough. The graphic and art style still look more like placeholders and most of the
menu and HUD are also placeholders. Second, the actual gameplay is not really fun
and has no really motivation for the player.&lt;/p&gt;
&lt;p&gt;However, the overall project was a great learning experience for me. The challenges
I had to face would not have been present like this if we had created the
game using an existing game engine. Some of the things I would do differently next time
are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;focus the design on one game element and test it&lt;/li&gt;
&lt;li&gt;use an engine for prototyping&lt;/li&gt;
&lt;li&gt;check if your game is actually fun to play&lt;/li&gt;
&lt;li&gt;let others test your game&lt;/li&gt;
&lt;li&gt;don't focus to early on optimizations&lt;/li&gt;
&lt;li&gt;Instead implement more flexible, general systems&lt;/li&gt;
&lt;li&gt;more communication between team members&lt;/li&gt;
&lt;li&gt;improve task distribution and don't try to do everything yourself&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Blender</category><category>C++</category><category>DirectX 11</category><guid>http://dasutt.github.io/posts/into-darkness-postmortem/</guid><pubDate>Fri, 20 May 2016 13:23:46 GMT</pubDate></item><item><title>Welcome</title><link>http://dasutt.github.io/posts/welcome/</link><dc:creator>Daniel Suttor</dc:creator><description>&lt;div&gt;&lt;p&gt;I decided to start blogging about some of the projects that I am currently working
on and have been working on in the last years.&lt;/p&gt;
&lt;p&gt;I will be focusing mostly on real time rendering and virtual reality and game
development. Currently I am planning to remove the dust from some of my projects
and making them presentable.&lt;/p&gt;&lt;/div&gt;</description><guid>http://dasutt.github.io/posts/welcome/</guid><pubDate>Wed, 11 May 2016 20:21:10 GMT</pubDate></item></channel></rss>